#!/usr/bin/env ruby
require 'optparse'

ProcessError = Class.new(StandardError)

$start_time = Time.now

module Colors
  def self.black;          "\e[30m" end
  def self.red;            "\e[31m" end
  def self.green;          "\e[32m" end
  def self.brown;          "\e[33m" end
  def self.blue;           "\e[34m" end
  def self.magenta;        "\e[35m" end
  def self.cyan;           "\e[36m" end
  def self.gray;           "\e[37m" end

  def self.reset;            "\e[0m" end
end

class Task

  @@task_number = 1

  def initialize(name, &block)
    @name = name
    @cmd = block
  end

  def run
    puts Colors::green
    puts "#{@@task_number}. #{@name}"
    puts '=' * 80

    puts Colors::cyan

    before = Time.now
    res = @cmd.call
    after = Time.now

    puts Colors::green
    passed = human_time((after - before) * 1000)
    puts "Finished in #{passed}"
    puts '=' * 80

    @@task_number += 1

    res
  end

end

def human_time(milisecs)
  units = ['ms', 1000, 's', 60, 'm', 60]

  parts = []

  left = milisecs.to_i
  i = 0

  while i < units.size do
    unit_label = units[i]
    till_next = units[i + 1]

    in_this_unit = left % till_next
    left -= in_this_unit
    left /= till_next

    parts.push(unit_label)
    parts.push(in_this_unit.to_s)

    break if left == 0

    i += 2
  end

  parts.push('h', left) if left > 0

  parts.reverse.take(6).join('')
end

def help
  puts $options_parser
  exit 1
end

def parse_options!
  OptionParser.new do |opts|
    $options_parser = opts
    opts.banner = "Usage: #{$0} <fasta_reads>"

    opts.on("-d", "--directory dirpath", "Set given dirpath as working directory") do |dir|
      set_working_dir(dir)
    end

    opts.on("-x", "--overlaps overlaps_file", "Skip overlap phase and use overlaps from given file") do |file|
      set_overlaps_path(file)
    end

    opts.on_tail("-h", "--help", "Show this message") do
      help
    end

  end.parse!
end

def parse_arguments
  if ARGV.length < 1
    help
  end

  ARGV.take 1
end

def ensure_dir(dirpath)
  cmd = "mkdir -p #{dirpath}"
  puts(cmd)
  system(cmd)
end

def assembler_dir
  File.dirname(__dir__)
end

def run_graphmap(reads_path)
  overlaps_path = File.join(working_dir, 'overlaps.mhap')
  binary = File.join(assembler_dir, 'components', 'graphmap', 'bin', 'Linux-x64', 'graphmap')
  cmd = "#{binary} -w owler -B 0 -r #{reads_path} -d #{reads_path} -L mhap -o #{overlaps_path}"
  puts(cmd)
  if !system(cmd)
    fail(ProcessError, 'Process exited with non-zero exit code')
  end
  overlaps_path
end

def run_layout(reads_path, overlaps_path)
  binary = File.join(assembler_dir, 'components', 'ra', 'bin', 'layout')
  cmd = "#{binary} #{reads_path} #{overlaps_path}"
  puts(cmd)
  if !system(cmd)
    fail(ProcessError, 'Process exited with non-zero exit code')
  end
end

$options_parser = nil

$options = {}

def working_dir
  if $options.has_key?(:working_dir)
    return $options[:working_dir]
  end

  suffix = $start_time.strftime("%Y%m%d_%H%M%S")
  $options[:working_dir] = "assembly.#{suffix}"
end

def set_working_dir(str)
  $options[:working_dir] = str
end

def set_overlaps_path(str)
  $options[:overlaps_path] = str
end

def main
  parse_options!
  reads_path,  = parse_arguments
  overlaps_path = $options[:overlaps_path]

  puts Colors::green

  Task.new "PREPARING ASSEMBLY DIRECTORY" do
    if !ensure_dir(working_dir)
      puts 'Process exited with non-zero exit status, stopping here!'
      exit 1
    end
  end.run

  Task.new "RUNNING GRAPHMAP" do
    begin
      if overlaps_path.nil?
        overlaps_path = run_graphmap(reads_path)
      else
        puts "Skipping overlap phase, using overlaps from #{overlaps_path}!"
      end
    rescue ProcessError
      puts 'Process exited with non-zero exit status, stopping here!'
      exit 1
    end
  end.run

  Task.new "RUNNING LAYOUT" do
    begin
      run_layout(reads_path, overlaps_path)
    rescue ProcessError
      puts 'Process exited with non-zero exit status, stopping here!'
      exit 1
    end
  end.run

  passed = human_time((Time.now - $start_time) * 1000)
  puts "Assembly total time #{passed}"
  puts '=' * 80
end

begin
  main()
rescue
  puts Colors::reset
  raise
ensure
  puts Colors::reset
end
